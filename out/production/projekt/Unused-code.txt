// Calculating bouncing angles with Pi, NOT WORKING AS INTENDED

        /*
        movingDirectionX = Math.sin(movingAngle) * movingStepSize;
        movingDirectionY = Math.cos(movingAngle) * movingStepSize;

        //Collision with border, checking X to right border
        if ((this.getCenterX() + getRadius() >= gameBoardSize)) {
            this.setCenterX(this.getCenterX()-movingStepSize);
            if((1.5*pi < movingAngle) && (movingAngle < 2*pi)){
                movingAngle = calculateBouncingAngle(movingAngle);
            }
            if((pi < movingAngle) && (movingAngle < pi*1.5)){
                movingAngle = movingAngle - pi/2;
            }
        }

        //Collision detection with border, checking X to left border
        if ((this.getCenterX() - getRadius() <= 0)) {
            this.setCenterX(this.getCenterX() + movingStepSize);
            if((0 < movingAngle) && (movingAngle < pi/2)){
                movingAngle = movingAngle + 1.5*pi;
            }
            if((pi/2 > movingAngle) && (movingAngle < pi)){
                movingAngle = movingAngle - pi/2;
            }
        }
        this.setCenterX(getCenterX() - movingDirectionX);
        this.setCenterY(getCenterY() - movingDirectionY);
        */

double calculateBouncingAngle(double incomingAngle) {
        double bouncedAngle = 0;
        double angleAxeDifference;
        if ((1.5 * pi < incomingAngle) && (incomingAngle < 2 * pi)) {
            angleAxeDifference = 2*pi - incomingAngle;
            bouncedAngle = angleAxeDifference;
        }
        return bouncedAngle;
    }